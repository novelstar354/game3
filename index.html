<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>表示確認用シューティング（矩形版）</title>
<style>
  html,body{height:100%;margin:0;background:#071021;color:#fff;font-family:sans-serif}
  .wrap{max-width:900px;margin:12px auto;padding:12px}
  canvas{width:100%;height:60vh;background:#00131a;display:block;border-radius:8px}
  .hud{display:flex;gap:12px;margin-top:8px;align-items:center}
  button{padding:8px 12px;border-radius:6px;border:0;background:#39f;color:#012;font-weight:700;cursor:pointer}
</style>
</head>
<body>
<div class="wrap">
  <h2>表示確認シューティング</h2>
  <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
    <button id="startBtn">Start</button>
    <button id="pauseBtn">Pause</button>
    <button id="restartBtn">Restart</button>
  </div>

  <canvas id="game"></canvas>

  <div class="hud">
    <div>Score: <span id="score">0</span></div>
    <div>Life: <span id="life">3</span></div>
    <div style="opacity:.7">Controls: ← → / Space = shoot / P = pause</div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  function resize(){
    const r = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(300, rect.width) * r;
    canvas.height = Math.max(200, rect.height) * r;
    ctx.setTransform(r,0,0,r,0,0);
  }
  window.addEventListener('resize', resize);
  // ensure canvas has size after layout
  setTimeout(resize, 50);

  // state
  let running = false;
  let paused = false;
  let last = performance.now();
  let score = 0, life = 3;
  const player = { x: 150, y: 200, w: 36, h: 24, speed: 240, cooldown:0 };
  const bullets = [];
  const enemies = [];

  // spawn an enemy periodically
  let spawnTimer = 0;

  function reset(){
    score = 0; life = 3;
    bullets.length = 0; enemies.length = 0;
    const r = window.devicePixelRatio || 1;
    player.x = (canvas.width / r)/2 - player.w/2;
    player.y = (canvas.height / r) - 80;
    document.getElementById('score').textContent = score;
    document.getElementById('life').textContent = life;
  }
  reset();

  function spawnEnemy(){
    const r = window.devicePixelRatio || 1;
    const W = canvas.width / r;
    const w = 36;
    enemies.push({ x: Math.random()*(W - w - 20) + 10, y: -40, w: w, h: 28, speed: 60 + Math.random()*60 });
  }

  function update(dt){
    if(paused) return;

    // move player by keys
    if(keys.left) player.x -= player.speed * dt;
    if(keys.right) player.x += player.speed * dt;
    const r = window.devicePixelRatio || 1;
    const W = canvas.width / r;
    player.x = Math.max(6, Math.min(W - player.w - 6, player.x));

    // shooting
    if(player.cooldown > 0) player.cooldown -= dt;
    if(keys.fire && player.cooldown <= 0){
      bullets.push({ x: player.x + player.w/2 - 4, y: player.y - 12, w:8, h:12, speed: 420 });
      player.cooldown = 0.22;
    }

    // bullets
    for(let i = bullets.length-1; i>=0; i--){
      bullets[i].y -= bullets[i].speed * dt;
      if(bullets[i].y < -40) bullets.splice(i,1);
    }

    // spawn
    spawnTimer -= dt;
    if(spawnTimer <= 0){
      spawnTimer = 0.9;
      spawnEnemy();
    }

    // enemies movement & simple collision with bullets
    for(let i = enemies.length-1; i>=0; i--){
      const e = enemies[i];
      e.y += e.speed * dt;
      // if enemy off bottom, remove
      if(e.y > canvas.height + 40) { enemies.splice(i,1); continue; }

      // collision with bullets
      for(let j = bullets.length-1; j>=0; j--){
        const b = bullets[j];
        if(!(b.x+b.w < e.x || b.x > e.x+e.w || b.y+b.h < e.y || b.y > e.y+e.h)){
          bullets.splice(j,1);
          enemies.splice(i,1);
          score += 10;
          document.getElementById('score').textContent = score;
          break;
        }
      }
    }
  }

  function draw(){
    const r = window.devicePixelRatio || 1;
    const W = canvas.width / r, H = canvas.height / r;
    ctx.clearRect(0,0,W,H);

    // background (simple)
    ctx.fillStyle = '#00131a';
    ctx.fillRect(0,0,W,H);

    // player (blue rectangle)
    ctx.fillStyle = '#39f';
    ctx.fillRect(player.x, player.y, player.w, player.h);
    // player gun tip for visibility
    ctx.fillStyle = '#aef';
    ctx.fillRect(player.x + player.w/2 -2, player.y - 6, 4, 6);

    // bullets
    ctx.fillStyle = '#fff';
    bullets.forEach(b => ctx.fillRect(b.x, b.y, b.w, b.h));

    // enemies
    ctx.fillStyle = '#f55';
    enemies.forEach(e => ctx.fillRect(e.x, e.y, e.w, e.h));

    // paused overlay
    if(paused){
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#fff';
      ctx.font = '24px sans-serif';
      ctx.fillText('PAUSED', W/2 - 36, H/2);
    }
  }

  function loop(ts){
    const dt = Math.min(0.05, (ts - last) / 1000);
    last = ts;
    if(running) update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // input
  const keys = { left:false, right:false, fire:false };
  window.addEventListener('keydown', e=>{
    if(e.key === 'ArrowLeft') keys.left = true;
    if(e.key === 'ArrowRight') keys.right = true;
    if(e.code === 'Space') { keys.fire = true; e.preventDefault(); }
    if(e.key.toLowerCase() === 'p') paused = !paused;
  });
  window.addEventListener('keyup', e=>{
    if(e.key === 'ArrowLeft') keys.left = false;
    if(e.key === 'ArrowRight') keys.right = false;
    if(e.code === 'Space') keys.fire = false;
  });

  // UI buttons
  document.getElementById('startBtn').addEventListener('click', ()=>{ running = true; paused = false; last = performance.now(); });
  document.getElementById('pauseBtn').addEventListener('click', ()=>{ paused = !paused; });
  document.getElementById('restartBtn').addEventListener('click', ()=>{ reset(); });

  // initial small move to ensure visible
  player.x = 120;
  player.y = 220;
})();
</script>
</body>
</html>
