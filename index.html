<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>かんたんシューティング（敵種類＋ボス＋アニメ）</title>
<style>
  :root{ --bg:#0b1220; --accent:#39f; }
  html,body{margin:0;height:100%;background:#071021;color:#eef;font-family:sans-serif;}
  .wrap{max-width:900px;margin:auto;padding:10px;}
  canvas{width:100%;height:60vh;max-height:700px;background:#020c18;border-radius:8px;display:block;}
  header{display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:10px;}
  button{background:var(--accent);color:white;border:none;padding:8px 12px;border-radius:6px;font-size:14px;cursor:pointer;}
  .hud{display:flex;justify-content:space-between;margin-top:6px;font-size:14px;}
  .touch-controls{display:flex;justify-content:center;gap:20px;margin-top:8px;}
  .touch-btn{background:#ffffff22;color:white;padding:14px 18px;font-size:20px;border-radius:10px;user-select:none;}
  .touch-btn:active{background:#ffffff55;}
  @media (min-width:768px){ .touch-controls{display:none;} }
</style>
</head>
<body>
<div class="wrap">
<header>
  <h2>かんたんシューティング</h2>
  <div>
    <button id="startBtn">開始</button>
    <button id="restartBtn">リスタート</button>
  </div>
</header>
<canvas id="game"></canvas>
<div class="hud">
  <div>スコア: <span id="score">0</span></div>
  <div>ライフ: <span id="life">3</span></div>
  <div>レベル: <span id="level">1</span></div>
</div>
<div class="touch-controls">
  <div class="touch-btn" id="leftBtn">◀</div>
  <div class="touch-btn" id="fireBtn">●</div>
  <div class="touch-btn" id="rightBtn">▶</div>
</div>
</div>
<script>
(() =>{
  const canvas=document.getElementById('game');
  const ctx=canvas.getContext('2d');

  function fit(){
    const r=window.devicePixelRatio||1;
    const rect=canvas.getBoundingClientRect();
    canvas.width=rect.width*r;
    canvas.height=rect.height*r;
    ctx.setTransform(r,0,0,r,0,0);
  }
  window.addEventListener('resize',fit);
  fit();

  let running=false,last=0;
  let score=0,life=3,level=1;
  const bullets=[],enemies=[],effects=[];
  let boss=null,bossTimer=0;

  const player={x:150,y:0,w:40,h:28,speed:260,cooldown:0};

  const keys={left:false,right:false,fire:false};

  function reset(){
    score=0;life=3;level=1;
    bullets.length=0;enemies.length=0;effects.length=0;
    boss=null;bossTimer=0;
    player.x=canvas.width/(window.devicePixelRatio||1)/2-player.w/2;
    player.y=canvas.height/(window.devicePixelRatio||1)-70;
  }
  reset();

  // --- エフェクト（爆発アニメ） ---
  function addEffect(x,y){
    effects.push({x,y,r:5,max:20,alpha:1});
  }

  // --- 敵生成（3種類＋たまに高速タイプ） ---
  function spawn(){
    const type=Math.random();
    const x=Math.random()*(canvas.width/(window.devicePixelRatio||1)-40)+10;

    // 小型（速い）
    if(type<0.4){ enemies.push({type:'small',x,y:-30,w:22,h:18,speed:120+level*20,hp:1}); }
    // 中型（標準）
    else if(type<0.8){ enemies.push({type:'mid',x,y:-40,w:30,h:24,speed:70+level*15,hp:2}); }
    // 大型（遅くて固い）
    else{ enemies.push({type:'big',x,y:-50,w:40,h:34,speed:40+level*10,hp:3}); }
  }

  // --- ボス登場 ---
  function spawnBoss(){
    const W=canvas.width/(window.devicePixelRatio||1);
    boss={x:W/2-80,y:-150,w:160,h:120,hp:60+level*20,speed:40,mode:'enter'};
  }

  function coll(a,b){return !(a.x+a.w<b.x||a.x>b.x+b.w||a.y+a.h<b.y||a.y>b.y+b.h);}  

  function update(dt){
    if(keys.left)player.x-=player.speed*dt;
    if(keys.right)player.x+=player.speed*dt;
    const max=canvas.width/(window.devicePixelRatio||1)-player.w;
    if(player.x<0)player.x=0;
    if(player.x>max)player.x=max;

    if(player.cooldown>0)player.cooldown-=dt;
    if(keys.fire&&player.cooldown<=0){
      bullets.push({x:player.x+player.w/2-3,y:player.y-12,w:6,h:12,speed:480});
      player.cooldown=0.2;
    }

    bullets.forEach((b,i)=>{b.y-=b.speed*dt;if(b.y<-20)bullets.splice(i,1);});

    // 敵出現（ボス前のみ）
    if(!boss){
      if(Math.random()<0.03*level)spawn();
    }

    // 敵更新
    enemies.forEach((e,i)=>{
      e.y+=e.speed*dt;
      if(coll(e,player)){
        enemies.splice(i,1);
        life--; if(life<=0)running=false;
        addEffect(player.x,player.y);
      }
      bullets.forEach((b,j)=>{
        if(coll(b,e)){
          bullets.splice(j,1);
          e.hp--; addEffect(b.x,b.y);
          if(e.hp<=0){ enemies.splice(i,1); score+=10; }
        }
      });
    });

    // ボス出現条件
    if(score>0 && score%200>=0 && bossTimer<=0 && !boss){
      bossTimer=20; // 次回ボス出現待機
      spawnBoss();
    }

    if(bossTimer>0)bossTimer-=dt;

    // ボス更新
    if(boss){
      if(boss.mode==='enter'){
        boss.y+=boss.speed*dt;
        if(boss.y>40)boss.mode='fight';
      } else if(boss.mode==='fight'){
        boss.x += Math.sin(Date.now()*0.001)*2;
      }

      if(coll(boss,player)){
        life--; addEffect(player.x,player.y);
        if(life<=0)running=false;
      }

      bullets.forEach((b,j)=>{
        if(coll(b,boss)){
          bullets.splice(j,1);
          boss.hp--; addEffect(b.x,b.y);
          if(boss.hp<=0){ boss=null; score+=200; }
        }
      });
    }

    // エフェクト更新
    effects.forEach((ef,i)=>{
      ef.r+=0.8; ef.alpha-=0.03;
      if(ef.alpha<=0)effects.splice(i,1);
    });

    level=1+Math.floor(score/100);
  }

  function draw(){
    const W=canvas.width/(window.devicePixelRatio||1);
    const H=canvas.height/(window.devicePixelRatio||1);
    ctx.clearRect(0,0,W,H);

    // プレイヤー
    ctx.fillStyle="#9ef";
    ctx.fillRect(player.x,player.y,player.w,player.h);

    // 弾
    ctx.fillStyle="white";
    bullets.forEach(b=>ctx.fillRect(b.x,b.y,b.w,b.h));

    // 敵描画（種類ごとに色変更）
    enemies.forEach(e=>{
      if(e.type==='small') ctx.fillStyle="#ff8";
      else if(e.type==='mid') ctx.fillStyle="#f85";
      else ctx.fillStyle="#f44";
      ctx.fillRect(e.x,e.y,e.w,e.h);
    });

    // ボス描画
    if(boss){
      ctx.fillStyle="#8ff";
      ctx.fillRect(boss.x,boss.y,boss.w,boss.h);
      ctx.fillStyle="#fff";
      ctx.fillRect(boss.x,boss.y-10,(boss.hp/ (60+level*20))*boss.w,6);
    }

    // エフェクト（爆発）
    effects.forEach(ef=>{
      ctx.globalAlpha=ef.alpha;
      ctx.fillStyle="orange";
      ctx.beginPath();
      ctx.arc(ef.x,ef.y,ef.r,0,Math.PI*2);
      ctx.fill();
      ctx.globalAlpha=1;
    });
  }

  function loop(t){
    const dt=(t-last)/1000; last=t;
    if(running)update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // キーボード
  window.addEventListener('keydown',e=>{
    if(e.key==='ArrowLeft')keys.left=true;
    if(e.key==='ArrowRight')keys.right=true;
    if(e.code==='Space')keys.fire=true;
    if(e.key==='Enter')running=true;
  });
  window.addEventListener('keyup',e=>{
    if(e.key==='ArrowLeft')keys.left=false;
    if(e.key==='ArrowRight')keys.right=false;
    if(e.code==='Space')keys.fire=false;
  });

  // タッチ
  function bindTouch(id,down,up){
    const el=document.getElementById(id);
    el.addEventListener('touchstart',e=>{e.preventDefault();down();});
    el.addEventListener('touchend',e=>{e.preventDefault();up();});
  }
  bindTouch('leftBtn',()=>keys.left=true,()=>keys.left=false);
  bindTouch('rightBtn',()=>keys.right=true,()=>keys.right=false);
  bindTouch('fireBtn',()=>keys.fire=true,()=>keys.fire=false);

  // UI
  document.getElementById('startBtn').onclick=()=>running=true;
  document.getElementById('restartBtn').onclick=()=>{reset();running=true;};
})();
</script>
</body>
</html>
